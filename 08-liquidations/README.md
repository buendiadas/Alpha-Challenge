# Liquidations - Tier 3
It’s DeFi Summer, and you run one of the most successful liquidators on Compound v2. On August 20, 2020, you realize that you are losing market share to [this address](https://etherscan.io/tx/0xec4f2ab36afa4fac4ba79b1ca67165c61c62c3bb6a18271c18f42a6bdfdb533d). This is odd because you updated the trading setup after [this proposal](https://compound.finance/governance/proposals/19), and have consistently won almost all liquidations since then.


## a) What’s the edge of this liquidator that allows them to win more liquidations?

He is using the compound oracle (which he might be receiving offchain from a reporter, or reading the mempool) to include it in the same transaction as the liquidation. It should be possible to outbid him by reading the mempool, so we need to check the callData and extract the values he is trying to use to liquidate the user. 
## b) When you figure out the source of the edge, you notice that their calldata is extremely obfuscated. Can you explain on how the calldata works?

This one was challenging, nothing is hidden onchain, but this one was particularly obfuscated on purpose. The key thing to identify was that the payload had different techniques using XORs and shifts on the payload to actually construct the clean payload he finally uses. Let's go through this step by step. 

We will need to check out what the transaction in question does in detail, it will be required to use a debugger to see the opcodes. I used [forge debugger](https://book.getfoundry.sh/forge/debugger), and just make a call impersonating the EOA of the executor. After making forge debug, it was possible to identify the following:

1. The first 4 bytes represent the function selector
2. The 32 bytes from `0x44` to `0x64` are used to decode the target address to delegate call, by XORing that value with `address(this)`. The result is `0x15135a5aac54aa5935f6254377d43750de2b8136` 
3. From `0xe4` to the end of the payload (`744 bytes`) there is a direct relationship from each `32 bytes` to the payload received at `0x15135a5aac54aa5935f6254377d43750de2b8136`, which is unencoded
4. The algorithm to encode each `32 bytes` is as follows:
    - There are two keys required to decode each `32 bytes` word:
       -  The first one is static (let's call it `MASTER_KEY`). This key is generated by doing XOR (`address(this)`, SHIFT LEFT (`address(this)`))
       -  The second one depends on the number of the word it is being decoded, let's call it `DYNAMIC_KEY(N)`. This function works as follows:
            - `DYNAMIC_KEY(0)` = `MASTER_KEY`
            - `DYNAMIC_KEY(N)` = `ADD(DYNAMIC_KEY(N-1) + MASTER_KEY)`
    - Each word can be decoded by doing `XOR(DATA, DYNAMIC_KEY(N))`

```

[0x00] 3743cb3f -> Function selector
[0x04]  6afae95100000000000000000000000000000000000000000000000000000034 -> Loaded into stack, not data
[0x24]  0000000000000000000000000000000000000000000000000000000000000000 -> Loaded into stack, not data
[0x44]  0000000000000000000000009d9b321b6398150d984de5f5be1f9bba60efaabd -> Decoded by XORing this value with address(this) gets the target address to delegate call to (0x15..) 
[0x64]  00000000000000000000000000000000000000000000000000000000000000a0 -> Is < uint32().max? [160], not data
[0x84]  00000000000000000000000000000000000000000000000000000000000000c0 -> Loaded into stack (after 0xa4) , not data
[0xa4]  0000000000000000000000000000000000000000000000000000000000000000 -> Loaded into stack (compared against type(uint32).max), not data
[0xc4]  0000000000000000000000000000000000000000000000000000000000000744 -> Length of payload: PC:1494 Loaded into stack (after 0x84) [uint32] 1860



In the next 744 bytes from here, every word has a direct translation into the payload that will be forwarded via delegationcall to the decoded address at 0x44 
(0x15135a5aac54aa5935f6254377d43750de2b8136). 



[0xe4]  298e3e019f997ea95b77816c82878956bf2b7ad1161a3c0c875b477848ff2cbd -> Decoded: function selector + cDAI (debt token within Compound)
[0x104] 0d170e866f663dfe09334222c3cb4e021ec59386307bd0495f9ab73ea25128a6 -> Decoded: cETH (collateral token)
[0x124] 3a06afd23f32fd52b6ef02d9050f12ade2f9d0be89af83eeb4158f55706a7246 -> Decoded: Liquidation victim address (0x26db83c03f408135933b3cff8b7adc6a7e0adebc)
[0x144] d4a0d7f5640555f664aac38f4652d759352ae85e64aac391f0fa6095b9d4d9b7 -> Decoded: 0x 7e 0a de bc 6a fa e9 51 (we know the relevant values are the last 4 bytes) 1794.828625
[0x164] 3336714a21338403ed997bba786963fb59cc82c1ed997bb74539f27f8766fabd -> All 0xFF (28 bytes)
        444526335166c4af3fddbb0437259f4fe8c3ede23fddbb007b6e4594c8a2cf32
        bbbcbdf1819a055a9221fa4df5e1daa477bb59029221fa49b1a298aa09dea3a7
        333455af4e32b9fa1b99c6684b61ea06f94d3bdd1b99c66d18291440b4e587e3
        555413f21dff794ec955871e8ca5aeb26a55d0bcc9558723e1f4c12b73a9b36e
        dddc7b53edcc38a3771147d4cde9735ddb5e659c771147daabc06e16326ddef9
        6664e2b5bd98f7f824cd088b0f2d38094c66fa7c24cd0891758c1b00f1320a84
        eeed4a978d65b74cd288c9415070fcb4bd6f8f5bd288c9483f57c7ebaff6360f
        7775b3995d3276a1804489f791b4c1602e78243b804489ff092374d66eba619a
        fffe1bdb2cff35f62e004aadd2f8860b9f80b91b2e004ab5d2ef21c12d7e8d25
        8886841cfccbf54adbbc0b64143c4ab710894dfadbbc0b6c9cbaceabec42b8b0
        110eec5fcc98b49f8977cc1a55800f628191e2da8977cc2366867b96ab06e43b
        999754809c6573f437338cd096c3d40df29a77ba37338cda3052288169cb0fc6
        221fbc826c323348e4ef4d86d80798b963a30c99e4ef4d90fa1dd56c288f3b51
        aaa826243bfef29d92ab0e3d194b5d64d4aba17992ab0e47c3e98256e75366dc
        333089060bcbb1f24066cef35a8f221045b436594066cefe8db52f41a6179267
        bbb8f5a5db987146ee228fa99bd2e6bbb6bccb38ee228fb55780dc2c64dbbdf2
        44415da9ab65309b9bde505fdd16ab6727c560189bde506c214c8917239fe97d
        ccc9c74b7b31eff0499a11161e5a701298cdf4f8499a1122eb183601e2641508
        55522f6d4afeaf44f755d1cc5f9e34be09d689d7f755d1d9b4e3e2eca1284093
        ddda962f1acb6e99a5119282a0e1f9697adf1eb7a51192907eaf8fd75fec6c1e
        395f7c98ea982dee52cd5338e225be14ebe7b39752cd5347487b3cc21eb097a9
        eeeb67f2ba64ed43008913ef236982c05cf04877008913fe1246e9acdd74c334
        60dc0b4c8a31ac97ae44d4a564ad476bcdf8dd56ae44d4b4dc1296979c38eebf
        fffc37b0298c028f3973955ba5f10c173f0172365c00956ba5de43825afd1a4a
        88849ff829cb2b4109bc5611e734d0c2b00a071609bc56226fa9f06d19c145d5
        110d083abcc3a295b77816c82878956e21129bf5b77816d939759d57d8857160
        9995707bc964a9ea6533d77e69bc5a19921b30d56533d79003414a4297499ceb
        221dd9bd9931693f12ef9834ab001ec50323c5b512ef9846cd0cf72d560dc876
        aaa6407f68fe2893c0ab58eaec43e370742c5a94c0ab58fd96d8a41814d1f401
        6c132b2938cae7e86e6719a12d87a81be534ef746e6719b460a45102d3961f8c
        bbb711430897a73d1c22da576ecb6cc7563d84541c22da6b2a6ffded925a4b17
        4430256bd8646691c9de9b0db00f3172c7461933c9de9b21f43baad8511e76a2
        ccc7e200d8434c8512e95bc3f152f61e384eae13779a5bd8be0757c30fe2a22d
        55504a4877fde53b25561c7a3296bac9a95742f325561c8f87d304adcea6cdb8
        ddd8b289038bed8fd311dd3073da7f751a5fd7d2d311dd46519eb1988d6af943
        66611acc179763e480cd9de6b51e44208b686cb280cd9dfd1b6a5e834c2f24ce
        eee9830fe76423392e895e9cf66208cbfc7101922e895eb3e5360b6e0af35059
        7771eb0fb730e28ddc451f5337a5cd776d799671dc451f6aaf01b858c9b77be4
        fffa535186fda1e28a00e00978e99222de822b518a00e02178cd6543887ba76f
        8882bbb386704ff426dadd4b789390a6faecacd8656d97e916492b1546e6e528
        7f12772846abefeecc77c8c18e77547a5ad26c99b1080d1b1b1ca2fc1c12d158
        d4bbb06bf663dfe09334222c3cb4e025319be9f093342245d6306c03c4c82a10
        221bf483c6309f3540efe2e27df8a4d0a2a47ed040efe2fc9ffc18ee838c559b
        aaa45cba6f7f4f9bb4cd3d5f207ef33d39672631afb3c577d4f21272498bf66f
        6b7be32e19b8f8254580fba13b9874ae2997281f3b65043286e198fa3f08ac89
        572245313596dd334a23250541c3f2d2f5be3d6f4a232520fd5f1faebfd8d83c
        443d95bb05639c87f7dee5bb8307b77e66c6d24ef7dee5d7c72acc997e9d03c7
        ccc5fde3d5305bdca59aa671c44b7c29d7cf672ea59aa68e90f679843d612f52
        554e6663a4fd1b3153566728058f40d548d7fc0e535667455ac2266efc255add
        ddd6cee574c9da86011227de46d30580b9e090ee011227fc248dd359bae98668
        665f36a401c2d1daaecde8948816ca2c2ae925cdaecde8b2ee59804479adb1f3
        eee79ee91463592f5c89a94ac95a8ed79bf1baad5c89a969b8252d2f3871dd7e
        77700729a07151840a456a010a9e53830cfa4f8d0a456a2081f0da19f7360909
        fff86f6c00000000000000000000000000000000000000000000000000000000
```

After decoding everything the data is ready in memory for the delegatecall, with a direct relationship each word to another. Below it can be seen some of the data that I identified. There are parts of data that aren't decoded, but I will do it if I need it to develop the bot in the next section.

```
0x
0000000000000000000000005d3a536e4d6dbd6114cc1ead35777bab948e3643 -> cDAI (debt token in Compound)
0000000000000000000000004ddc2d193948926d02f9b1fe9e1daa0718270ed5 -> cETH (coll token in Compound)
00000000000000000000000026db83c03f408135933b3cff8b7adc6a7e0adebc -> Victim address
6afae951000000000000000000000000000000000000000000000000000400c0 -> ???
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> ???
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> ???
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff -> ???
0000000000000000000000000000000000000000000000000000000000000160 
0000000000000000000000000000000000000000000000000000000000000180
00000000000000000000000000000000000000000000000000000000000001a0
00000000000000000000000000000000000000000000000000000000000001c0
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000001
0000000000000000000000000000000000000000000000000000000000000020
0000000000000000000000000000000000000000000000000000000000000060
0000000000000000000000000000000000000000000000000000000000000300
0000000000000000000000000000000000000000000000000000000000000460
0000000000000000000000000000000000000000000000000000000000000002 -> 2 item array
0000000000000000000000000000000000000000000000000000000000000040 -> Offset 2 is where data is
0000000000000000000000000000000000000000000000000000000000000160 -> 
0000000000000000000000000000000000000000000000000000000000000100
0000000000000000000000000000000000000000000000000000000000000080
000000000000000000000000000000000000000000000000000000005f3d8268 -> ETH Price
00000000000000000000000000000000000000000000000000000000000000c0 
0000000000000000000000000000000000000000000000000000000017afc438 -> DAI Price.
0000000000000000000000000000000000000000000000000000000000000006
7072696365730000000000000000000000000000000000000000000000000000 -> Prices tag
0000000000000000000000000000000000000000000000000000000000000003
4554480000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000100
0000000000000000000000000000000000000000000000000000000000000080
000000000000000000000000000000000000000000000000000000005f3d8268 -> ETH Price
00000000000000000000000000000000000000000000000000000000000000c0 
00000000000000000000000000000000000000000000000000000000000f5caf -> DAI Price.
0000000000000000000000000000000000000000000000000000000000000006 -> Length of prices tag in bytes (6)
7072696365730000000000000000000000000000000000000000000000000000 -> Prices tag
0000000000000000000000000000000000000000000000000000000000000003 -> Length in bytes
4441490000000000000000000000000000000000000000000000000000000000 -> DAI tag
0000000000000000000000000000000000000000000000000000000000000002 -> Length of array
0000000000000000000000000000000000000000000000000000000000000040 -> Offset of data start
00000000000000000000000000000000000000000000000000000000000000c0 -> Length of data for the signature array (6x32 bytes)
0000000000000000000000000000000000000000000000000000000000000060 Length of next signature
d0ba2ec311667df4c2bec668b5666ce952d1373154d0393b01d937d26e19533d Signature 1 R
603ccf65290fa9b475064f039a41398954706c9417781de51a112fdd4d283c3d Signature 1 S
000000000000000000000000000000000000000000000000000000000000001b Signature 1 V
0000000000000000000000000000000000000000000000000000000000000060 Length of next signature
fa8211125a669ec79f429a412aca359e411866c4bd35d7ab0bdb774958572632 Signature 2 R
7c72e5fbd9e79fee3b185a89ad228090a7026058b572ea3e3e1c0038ec97686f Signature 2 S
000000000000000000000000000000000000000000000000000000000000001b Signature 2 V
0000000000000000000000000000000000000000000000000000000000000002 -> Amount of bytes array size (2)
0000000000000000000000000000000000000000000000000000000000000040 -> Start of data (offset 2x32 bytes)
0000000000000000000000000000000000000000000000000000000000000080 -> Length of data (4 x 32 bytes)
0000000000000000000000000000000000000000000000000000000000000003 -> length of tag (bytes)
4554480000000000000000000000000000000000000000000000000000000000 -> ETH tag
0000000000000000000000000000000000000000000000000000000000000003 -> length of tag (bytes)
4441490000000000000000000000000000000000000000000000000000000000 -> DAI tag
0000000000000000000000000000000000000000000000000000000000000080
000000000000000000000000000000000000000000000000000000005f3d8268 -> 1597.866600
00000000000000000000000000000000000000000000000000000000000000c0
0000000000000000000000000000000000000000000000000000000017afc438 -> 3973.95000
0000000000000000000000000000000000000000000000000000000000000006
7072696365730000000000000000000000000000000000000000000000000000 -> prices
0000000000000000000000000000000000000000000000000000000000000003
4554480000000000000000000000000000000000000000000000000000000000 -> ETH
```


- c) Write code for the bot in Solidity, and provide all necessary information to simulate this liquidation on a mainnet fork.

